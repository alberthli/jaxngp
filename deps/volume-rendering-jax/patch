diff --git a/deps/volume-rendering-jax/lib/impl/marching.cu b/deps/volume-rendering-jax/lib/impl/marching.cu
index 087a620..bcf5da3 100644
--- a/deps/volume-rendering-jax/lib/impl/marching.cu
+++ b/deps/volume-rendering-jax/lib/impl/marching.cu
@@ -143,7 +143,7 @@ __global__ void march_rays_kernel(
         std::uint32_t const occupancy_grid_idx = cascade * G3 + __morton3D(grid_x, grid_y, grid_z);
         bool const occupied = occupancy_bitfield[occupancy_grid_idx >> 3] & (1 << (occupancy_grid_idx & 7u));  // (x>>3)==(int)(x/8), (x&7)==(x%8)
 
-        ray_t += ds;
+        float new_ray_t = ray_t + ds;
         if (occupied) {
             ++ray_n_samples;
         } else {
@@ -154,10 +154,11 @@ __global__ void march_rays_kernel(
             // distance to next voxel
             float const tt = ray_t + fmaxf(0.0f, fminf(tx, fminf(ty, tz)));
             // step until next voxel
-            while (ray_t < tt) { 
-                ray_t += calc_ds(ray_t, stepsize_portion, bound, iG, diagonal_n_steps);
-            } 
+            while (new_ray_t < tt) {
+                new_ray_t += calc_ds(new_ray_t, stepsize_portion, bound, iG, diagonal_n_steps);
+            }
         }
+        ray_t = new_ray_t;
     }
 
     // can safely return here because before launching the kernel we have `memset`ed every output
@@ -211,7 +212,7 @@ __global__ void march_rays_kernel(
         std::uint32_t const occupancy_grid_idx = cascade * G3 + __morton3D(grid_x, grid_y, grid_z);
         bool const occupied = occupancy_bitfield[occupancy_grid_idx >> 3] & (1 << (occupancy_grid_idx & 7u));  // (x>>3)==(int)(x/8), (x&7)==(x%8)
 
-        ray_t += ds;
+        float new_ray_t = ray_t + ds;
         if (occupied) {
             ray_xyzs[steps * 3 + 0] = x;
             ray_xyzs[steps * 3 + 1] = y;
@@ -231,10 +232,11 @@ __global__ void march_rays_kernel(
             // distance to next voxel
             float const tt = ray_t + fmaxf(0.0f, fminf(tx, fminf(ty, tz)));
             // step until next voxel
-            while (ray_t < tt) { 
-                ray_t += calc_ds(ray_t, stepsize_portion, bound, iG, diagonal_n_steps);
+            while (new_ray_t < tt) {
+                new_ray_t += calc_ds(new_ray_t, stepsize_portion, bound, iG, diagonal_n_steps);
             }
         }
+        ray_t = new_ray_t;
     }
 }
 
@@ -319,7 +321,7 @@ __global__ void march_rays_inference_kernel(
         std::uint32_t const occupancy_grid_idx = cascade * G3 + __morton3D(grid_x, grid_y, grid_z);
         bool const occupied = occupancy_bitfield[occupancy_grid_idx >> 3] & (1 << (occupancy_grid_idx & 7u));  // (x>>3)==(int)(x/8), (x&7)==(x%8)
 
-        ray_t += ds;
+        float new_ray_t = ray_t + ds;
         if (occupied) {
             ray_xyzs[steps * 3 + 0] = x;
             ray_xyzs[steps * 3 + 1] = y;
@@ -336,10 +338,11 @@ __global__ void march_rays_inference_kernel(
             // distance to next voxel
             float const tt = ray_t + fmaxf(0.0f, fminf(tx, fminf(ty, tz)));
             // step until next voxel
-            while (ray_t < tt) { 
-                ray_t += calc_ds(ray_t, stepsize_portion, bound, iG, diagonal_n_steps);
+            while (new_ray_t < tt) {
+                new_ray_t += calc_ds(new_ray_t, stepsize_portion, bound, iG, diagonal_n_steps);
             }
         }
+        ray_t = new_ray_t;
     }
     n_samples[i] = steps;
     t_starts_out[i] = ray_t;
